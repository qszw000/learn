1. JDK和JRE

   1. JRE：Java运行时环境，包含运行已编译Java程序的所有内容的集合，包括JVM（Java虚拟机），Java类库，Java命令及其他一些基本构件，但是不能创建和编译Java程序
   2. JDK：JDK包含JRE的一切，还有编译器Java和其他的调试和分析工具，能够创建和编译程序

2. ==和equals的区别

   1. ==：对于基础数据类型比较的是值是否相等，对于引用数据类型比较的内存地址是否相等
   2. equals：本质是调用==方法，一般会覆盖equals方法来比较两个对象的内容是否相等

   hashCode：作用是获取哈希码，返回一个int整数，用于确定对象在哈希表中的索引位置

   hashCode和equals的规定：

   1. 如果两个对象相等，则hashcode一定相同
   2. 如果两个对象相等，两个对象分别调用equals方法返回true
   3. 两个对象拥有相同的hashcode，调用equals方法不一定返回true
   4. equals方法被覆盖过，则hashcode方法也必须被覆盖

3. final关键字的作用

   final关键字主要作用三个地方：类，变量，方法

   1. final修饰一个类时，表示这个类不能被继承，final类中的所有成员方法都被隐式的指定为final方法
   2. final修饰一个变量时，如果是基本数据类型，则其值一旦在初始化之后不能更改，如果是引用变量，则再初始化之后不能再指向其他变量
   3. final修饰一个方法时，表示这个方法不能不被重写，防止任何继承类修改它的定义

4. static关键字的作用

   1. 修饰成员变量和成员方法：被static修饰的成员属于类，不属于单个类的某个对象，被类中所有对象共享，可以并建议通过使用类名调用。被static修饰的成员变量属于静态成员变量存放在Java内存的方法区
   2. 静态代码块：静态代码块定义在类中方法外，静态代码在非静态代码之前执行（静态代码块->非静态代码块->构造函数）该类不管创建多少对象，静态代码块只执行一次
   3. 静态内部类：静态内部类与非静态内部类最大的区别：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用指向创建它的外部类，但静态内部类没有。意味着静态内部类的创建不需要依赖外部类的创建，不能使用外部类的非static成员变量和方法
   4. 静态导包：可以直接使用类中静态成员变量和方法

5. Java的基本数据类型

   boolean，byte，short，int，long，float，double，char

6. String，StringBuilder，StringBuffer的区别

   1. 可变性：String，StringBuilder，StringBuffer都是通过字符数组来保存字符串，String类使用final关键字修饰字符数组，所以String对象是不可变的，每次操作都会产生新的String对象，然后把指针指向新的String对象。StringBuilder和StringBuffer是可变的，可以在原有对象的基础上进行操作
   2. 线程安全：String对象是不可变的，所以是线程安全的，StringBuffer对方法加了同步锁，所以是线程安全的，StringBuilder没有加同步锁，所以不是线程安全的
   3. 因为StringBuilder没有加同步锁，所以性能方面StringBuilder>StringBuffer>String

7. String str = "i" 和String str = new String("i")的区别

   1. 前者会判断常量池中是否有对象"i"，如果有则直接将str指向这个对象，如果没有先在常量池中创建对象"i"，然后再把str指向这个对象
   2. 后者会在堆中创建对象"i"，然后把str指向这个对象

8. 抽象类和普通类有哪些区别

   1. 普通类不能有抽象方法，抽象类可以有
   2. 普通类可以实例化，抽象类不可以

9. 接口和抽象类的区别

   1. 接口的方法默认是public，所有方法在接口中不能有实现（Java8可以使用default），抽象类可以有非抽象方法
   2. 接口中的除了static，final变量，不能有其他变量，抽象类可以
   3. 一个类可以使用implements实现多个接口，但只能使用extends继承一个抽象类
   4. 接口的默认访问修饰符是public，抽象类可以为public，protected和default

10. Java和C++的区别

    1. 都是面向对象语言，支持封装，继承，多态
    2. Java不提供指针直接访问内存，程序内存更加安全
    3. Java的类是单继承的，C++是多继承的；虽然Java的类不可以多继承，但是接口可以使用extends拓展多个接口
    4. Java有自动内存管理机制，不需要程序员手动释放内存

11. 重写与重载的区别

    1. 重载发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，返回值和访问修饰符可以不同
    2. 重写发生在子类中，方法名，参数列表必须相同，返回类型小于等于父类，抛出异常相遇访问修饰符大于等于父类

12. 在一个静态方法内调用一个非静态成员为什么是非法的

    类的静态成员属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问非静态成员变量。类的非静态成员属于类的对象，只有在类实例化的时候才会分配内存，如果通过类的对象去访问。如果一个类的静态方法去调用非静态方法或变量的时候，因为类的静态方法存在的时候，类的非静态成员不存在，所以是非法的

13. Error和Exception

    Error和Exception都继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者是捕获（catch)。Exception是程序正常运行中，可以预料的意外情况，可以并应该被捕获，并进行相应的处理。Error是指Java 运行时系统的内部错误和资源耗尽错误，在正常情况下不太可能出现的情况，绝大多数的Error都会导致程序处于非正常，不可恢复状态

14. throw和throws

    1. 位置不同：throws用在函数上，后面可以跟多个异常类；throw用于函数内，后面跟的是异常对象
    2. 功能不同：throws用于声明异常，让调用者只知道该功能可能出现的问题；throw抛出具体的问题对象，执行到throw，功能就结束了。throws表示出现异常的一种可能行，并不一定发生这些异常；throw则是一定是抛出了某种异常对象。

15. Java复制

    1. 直接赋值复制：a = b，实际上复制的是引用，a和b指向同一个对象，当a变化时，b里的成员变量也会变化
    2. 浅复制：创建一个新的对象，然后把对象的非静态字段复制到该新对象，如果字段是基本数据类型，那么对这个字段执行复制；如果字段是引用类型，则复制引用而不是复制引用的对象
    3. 深复制：深拷贝不止复制对象本身，而且复制对象包含的引用所指向的对象
    
    如何实现对象克隆
    
    1. 实现Cloneable接口并重写Object类的clone方法
    2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆
    
16. 什么是反射

    反射主要是在运行状态中，对任意一个类都能知道这个类所有的属性和方法；并且对与任意一个对象，都能够调用它的任意一个方法

    - 在运行时判断任意一个对象所属的类
    - 在运行时构造任意一个类的对象
    - 在运行时判断任意一个类所具有的成员变量和方法
    - 在运行时调用任意一个对象的方法

17. 动态代理是什么

    当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。 
    
18. final、finally、finalize 有什么区别

    - final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
    - finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
    - finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 