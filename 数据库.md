1. 存储过程

    一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。 

2. 触发器

   触发器是一段能自动执行的程序。触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器。 

3. 视图

   视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。视图具有表结构文件，但不存在数据文件。 

4. 数据库三范式

   1. 第一范式：保证每列的原子性，每列都是不可再分的最小数据单元
   2. 第二范式：非主键列不存在对主键的部分依赖
   3. 第三范式：非主键列不存在对主键列的传递依赖

5. 事务

   事务是一个满足ACID特性的工作逻辑单元。要么通过Commit全部提交执行，要不通过Rollback失败回滚

   1. 原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚
   2. 一致性：数据库在事务执行前后保持一致性状态，所有事务对同一数据的读取结果是相同的
   3. 隔离型： 对数据进行修改的所有并发事务是彼此隔离的，各并发事务之间是独立的； 
   4. 持久性：事务完成之后，对数据的修改是持久保持的，即使系统发生崩溃，事务执行的结果也不能丢失

6. 并发事务带来的问题

   1. 脏读：事务A修改一个数据，事务B读取这个数据，如果事务A撤销了这次修改，那么事务B读取的数据就是脏数据
   2. 修改丢失：事务A，B都对一个数据进行读取，事务A先修改，事务B后修改，事务B的修改覆盖了事务A的修改
   3. 不可重复读：事务A读取一个数据，事务B对这个数据做了修改，如果事务A再次读取这个数据，两次的读取结果不同
   4. 幻读：事务A读取了某个范围的数据，事务B在这个范围插入新的数据，事务A再次读取这个范围的数据时，两次的读取结果不相同

7. 事务隔离级别有哪些

   1. 读取未提交（READ- UNCOMMITTED）：允许读取尚未提交的数据变更
   2. 读取已提交（READ-COMMITTED）：允许读取并发事务已提交的数据
   3. 可重复读（REPEATABLE-READ）：对同一字段的多次读取结果是一致的，除非数据被自身事务所修改
   4. 可串行化（ SERIALIZABLE ）：所有事务依次逐个执行

8. 封锁粒度

   1. 行级锁：MySQL中锁定粒度最大的锁，对当前操作的整张表加锁，实现简单，资源消耗比较少，加锁快，不会出现死锁。其加锁粒度最大，触发锁冲突的概率最高，并发度最低
   2. 表级锁：MySQL中锁定粒度最小的锁，对当前操作的行加锁，行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度最高，但是加锁的开销也最大，加锁慢，会出现死锁

9. 封锁类型

   互斥锁，简称X锁也叫写锁；共享锁，简称S锁也叫读锁

   一个事务对数据对象A加X锁，就可以对A进行读取和更新操作。加锁期间其他事务不能对A加任何锁

   一个事务对数据对象A加S锁，就可以对A进行读取操作，但不能进行更新操作。加锁期间其他事务能对A加S锁，但不能加X锁

10. 封锁协议

    1. 三级封锁协议：

       一级封锁协议：事务T要修改数据A时必须加X锁，直到T结束才释放（可以解决丢失修改）

       二级封锁协议：在一级封锁协议的基础上，要求事务T读取数据A时必须加S锁，读取完马上释放S锁（可以解决脏读）

       三级封锁协议：在二级封锁协议的基础上，要求事务T读取数据A时必须加S锁，直到事务结束才释放S锁（可以解决不可重复读）

    2. 二段锁协议：

       两段锁协议是指每个事务的执行可以分为两个阶段：加锁阶段和衰退阶段解锁阶段。

       加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。

       解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

11. InnoDB存储引擎锁算法

    1. Record Locks：锁定一个记录的索引，不锁定记录本身
    2. Gap Locks：锁定索引之间的间隙，但不包含索引本身
    3. Next-Key Locks： Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙 

12. 索引

    MySQL索引使用的数据结构主要有哈希索引和B-Tree索引。

    1. 哈希索引：底层数据结构是哈希表，在查询单条记录时效率最高
    2. B-Tree索引：MySQl中B-Tree索引使用的是B+Tree，InnoDB和MyISAM两种存储引擎的实现方式是不同的
       1. MyISAM：MyISAM索引文件与数据文件是分离的，B+Tree的叶子节点的data域存放的时数据记录的地址。在索引检索的时候，首先根据B+Tree的搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为非聚簇索引
       2. InnoDB：InnoDB的表数据文件本身就是按照B+Tree组织成的一个索引结构，树的叶子节点的data域存放的完整的数据记录。这个索引的key是表的主键值。因此InnoDB表数据文件本身就是主索引，这被称为聚簇索引。其余的索引都是辅助索引，辅助索引的data域存储相应记录的主键值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出记录；在根据辅助索引搜索时，则需要先取出主键值，再走一遍主索引

    查询中哪些情况不会使用索引？

    1. 使用in 或 not in操作符
    2. 使用<>不等于操作符
    3. IS NULL 或 IS NOT NULL操作，判断是否为空
    4. 使用LIKE操作符的'LIKE %string%' 或 'LIKE %string'
    5. 不符合索引的最左匹配原则
    6. 查询条件有or分割时，存在某列没有索引
    7. where字句中对索引列有数学运算或者使用函数 
    8. 存在索引列的数据类型隐式转换

13. 数据库乐观锁与悲观锁

    1. 悲观锁：每次拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据的时候都会阻塞直到它拿到锁（共享资源每次只能给一个线程使用，其他线程阻塞，用完之后再把资源转让给其他线程）如行锁，表锁，读锁，写锁等
    2. 乐观锁：每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有更新这个数据，可以使用版本号和CAS算法实现，如MVCC

14. 多版本并发控制MVCC

    通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存了行的过期时间，每开启一个新的事物，系统版本号都会自动递增。事务开始时的系统版本号会作为事物版本号

    1. select：InnoDB只查询版本早于当前事务版本的数据行，这样可以保证事务读取的行，要么是在事务开始前就已经存储，要么是事务自身插入或修改的；行的删除版本号要么未定义，要么大于当前事务版本号，这可以保证事务读到的行，在事务开始前未被删除
    2. insert：InnoDB为新插入的每一行保存当前的系统版本号作为行版本号
    3. delete：InnoDB为删除的每一行保存当前的系统版本号作为行删除标识
    4. update：InnoDB为插入一条新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行的作为删除版本号

15. MyISAM与InnoDB的对比

    1. MyISAM只支持表级锁，而InnoDB支持行级锁和表级锁，默认是行级锁
    2. MyISAM不提供事务支持，InnoDB提供事务支持事务，具有事务，回滚，崩溃修复能力的事务安全型表
    3. MyISAM不支持外键，InnoDB支持外键
    4. MyISAM不支持MVCC，InnoDB支持

16. MySQL中一条SQL语句是如何执行的

    1. 连接器：主要和身份认证与权限相关的功能
    2. 查询缓存：主要用来缓存我们所执行的SELECT语句及该语句的结果集
    3. 分析器：
       1. 词法分析：提取关键字，查询的表，字段名，查询条件等
       2. 语法分析：判断SQL语句是否正确，是否符合MySQL的语法
    4. 优化器：选择优化器认为的最优执行方案去执行
    5. 执行器：执行前会校验用户权限，如果没有权限，返回错误信息，如果有权限，就会去调用引擎接口，返回接口执行结果